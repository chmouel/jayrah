#!/usr/bin/env -S uv --quiet run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "requests",
#     "google.genai",
#     "pyyaml",
# ]
# ///
"""CVE Triage Script - Categorize CVE issues by component using image pattern matching and Gemini AI."""

import argparse
import json
import os
import re
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path

import requests
import yaml

try:
    import google.genai as genai

    HAS_GEMINI = True
except ImportError:
    HAS_GEMINI = False
    genai = None


def load_config():
    """Load component mapping config from config.yaml."""
    config_path = Path(__file__).parent / "config.yaml"
    if not config_path.exists():
        print(f"Error: Config file not found at {config_path}")
        sys.exit(1)

    with open(config_path) as f:
        return yaml.safe_load(f)


def load_jayrah_config():
    """Load Jira credentials from jayrah config."""
    config_path = Path.home() / ".config" / "jayrah" / "config.yaml"
    if not config_path.exists():
        print(f"Error: Jayrah config not found at {config_path}")
        print("Please configure jayrah first: uv run jayrah browse")
        sys.exit(1)

    with open(config_path) as f:
        config = yaml.safe_load(f)

    general = config.get("general", {})

    # Handle pass:: password lookup
    password = general.get("jira_password", "")
    if password.startswith(("pass::", "passage::")):
        import subprocess

        prefix, key = password.split("::", 1)
        cmd = "pass" if prefix == "pass" else "passage"
        result = subprocess.run([cmd, key], capture_output=True, text=True)
        password = result.stdout.strip()

    return {
        "server": general.get("jira_server"),
        "user": general.get("jira_user"),
        "password": password,
        "auth_method": general.get("auth_method", "bearer"),
    }


class JiraClient:
    """Simple Jira API client for CVE triage."""

    def __init__(self, config):
        self.server = config["server"]
        self.base_url = f"{self.server}/rest/api/2"
        self.session = requests.Session()
        self.session.headers["Content-Type"] = "application/json"
        self.session.headers["Accept"] = "application/json"

        if config["auth_method"] == "bearer":
            self.session.headers["Authorization"] = f"Bearer {config['password']}"
        else:
            self.session.auth = (config["user"], config["password"])

    def search_issues(self, jql, start_at=0, max_results=100):
        """Search for issues using JQL."""
        params = {"jql": jql, "startAt": start_at, "maxResults": max_results}
        resp = self.session.get(f"{self.base_url}/search", params=params)
        resp.raise_for_status()
        return resp.json()

    def fetch_all_issues(self, jql):
        """Fetch all issues with pagination."""
        all_issues = []
        start_at = 0

        while True:
            result = self.search_issues(jql, start_at=start_at)
            issues = result.get("issues", [])
            all_issues.extend(issues)

            total = result.get("total", 0)
            start_at += len(issues)

            if start_at >= total or not issues:
                break

            print(f"  Fetched {start_at}/{total} issues...", file=sys.stderr)

        return all_issues

    def get_issue(self, issue_key):
        """Get a specific issue."""
        resp = self.session.get(f"{self.base_url}/issue/{issue_key}")
        resp.raise_for_status()
        return resp.json()

    def update_issue(self, issue_key, fields):
        """Update issue fields."""
        payload = {"fields": fields}
        resp = self.session.put(f"{self.base_url}/issue/{issue_key}", json=payload)
        resp.raise_for_status()
        return True

    def add_comment(self, issue_key, comment):
        """Add a comment to an issue."""
        payload = {"body": comment}
        resp = self.session.post(f"{self.base_url}/issue/{issue_key}/comment", json=payload)
        resp.raise_for_status()
        return True


def extract_image_from_issue(issue):
    """Extract container image name from issue summary/description."""
    summary = issue.get("fields", {}).get("summary", "")
    description = issue.get("fields", {}).get("description", "") or ""

    # Patterns to match image names
    patterns = [
        r"openshift-pipelines/([a-z0-9-]+)",  # openshift-pipelines/image-name
        r"registry\.redhat\.io/openshift-pipelines/([a-z0-9-]+)",
        r"pipelines-([a-z0-9-]+)-rhel\d*",  # pipelines-xxx-rhel9
    ]

    text = f"{summary} {description}"

    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            image = match.group(1) if match.lastindex else match.group(0)
            # Clean up rhel suffix
            image = re.sub(r"-rhel\d*(@.*)?$", "", image)
            return image

    return None


def map_image_to_component(image, components_config):
    """Map an image name to a Jira component using pattern matching."""
    if not image:
        return None

    image_lower = image.lower()

    for component in components_config:
        for pattern in component.get("patterns", []):
            if pattern.lower() in image_lower:
                return component["name"]

    return None


def get_current_component(issue):
    """Get the current component(s) from an issue."""
    components = issue.get("fields", {}).get("components", [])
    return [c.get("name") for c in components]


def setup_gemini(config):
    """Initialize Gemini API client."""
    if not HAS_GEMINI:
        print("Warning: google.genai not installed, LLM suggestions disabled")
        print("  Install with: pip install google-genai")
        return None

    api_key_env = config.get("gemini", {}).get("api_key_env", "GEMINI_API_KEY")
    api_key = os.environ.get(api_key_env)

    if not api_key:
        print(f"Warning: {api_key_env} not set, LLM suggestions disabled")
        return None

    client = genai.Client(api_key=api_key)
    model_name = config.get("gemini", {}).get("model", "gemini-2.0-flash")
    return {"client": client, "model": model_name}


def ask_gemini(gemini_ctx, issue, components_config, current_component):
    """Ask Gemini to suggest the correct component."""
    if not gemini_ctx:
        return None

    summary = issue.get("fields", {}).get("summary", "")
    description = issue.get("fields", {}).get("description", "") or ""

    # Truncate description if too long
    if len(description) > 2000:
        description = description[:2000] + "..."

    component_names = [c["name"] for c in components_config]

    prompt = f"""You are a security CVE triage assistant for OpenShift Pipelines.

Given this CVE issue:
- Summary: {summary}
- Description: {description}
- Current Component: {", ".join(current_component) if current_component else "None"}

Available components: {", ".join(component_names)}

Based on the image/package mentioned in the CVE, which component should this issue be assigned to?
Look for container image names like "pipelines-console-plugin-rhel9" or package paths.

Respond with ONLY valid JSON (no markdown):
{{"suggested_component": "component name", "confidence": "high|medium|low", "reasoning": "brief explanation"}}
"""

    try:
        response = gemini_ctx["client"].models.generate_content(
            model=gemini_ctx["model"],
            contents=prompt,
        )
        text = response.text.strip()
        # Clean up markdown code blocks if present
        text = re.sub(r"^```json\s*", "", text)
        text = re.sub(r"\s*```$", "", text)
        return json.loads(text)
    except Exception as e:
        print(f"  Gemini error: {e}", file=sys.stderr)
        return None


def analyze_issue(issue, config, gemini_model):
    """Analyze a single issue and return triage result."""
    key = issue.get("key")
    summary = issue.get("fields", {}).get("summary", "")
    current_components = get_current_component(issue)

    # Extract image and map to component
    image = extract_image_from_issue(issue)
    expected_component = map_image_to_component(image, config.get("components", []))

    result = {
        "key": key,
        "summary": summary[:80] + "..." if len(summary) > 80 else summary,
        "image": image,
        "current_components": current_components,
        "expected_component": expected_component,
        "is_miscategorized": False,
        "gemini_suggestion": None,
    }

    # Check if miscategorized
    if expected_component and expected_component not in current_components:
        result["is_miscategorized"] = True

    # Use Gemini for ambiguous cases
    if not expected_component or result["is_miscategorized"]:
        gemini_result = ask_gemini(
            gemini_model, issue, config.get("components", []), current_components
        )
        if gemini_result:
            result["gemini_suggestion"] = gemini_result
            if (
                gemini_result.get("suggested_component")
                and gemini_result["suggested_component"] not in current_components
            ):
                result["is_miscategorized"] = True

    return result


def cmd_list(args, config, jira, gemini_model):
    """List all CVE issues with triage analysis."""
    jql = config.get("jira", {}).get(
        "jql_filter", 'summary ~ "cve-*" AND labels = security'
    )
    project = config.get("jira", {}).get("project", "SRVKP")
    full_jql = f"project = {project} AND {jql}"

    print(f"Fetching issues with JQL: {full_jql}", file=sys.stderr)
    issues = jira.fetch_all_issues(full_jql)
    print(f"Found {len(issues)} issues", file=sys.stderr)

    miscategorized = []

    for issue in issues:
        result = analyze_issue(issue, config, gemini_model)

        if result["is_miscategorized"] or args.all:
            miscategorized.append(result)

    # Output results
    if args.json:
        print(json.dumps(miscategorized, indent=2))
    else:
        if not miscategorized:
            print("No miscategorized issues found.")
            return

        print(f"\n{'=' * 80}")
        print(f"Found {len(miscategorized)} potentially miscategorized issues:")
        print(f"{'=' * 80}\n")

        for r in miscategorized:
            print(f"Issue: {r['key']}")
            print(f"  Summary: {r['summary']}")
            print(f"  Image: {r['image'] or 'Not detected'}")
            print(f"  Current: {', '.join(r['current_components']) or 'None'}")
            if r["expected_component"]:
                print(f"  Expected: {r['expected_component']}")
            if r["gemini_suggestion"]:
                g = r["gemini_suggestion"]
                print(
                    f"  Gemini: {g.get('suggested_component')} ({g.get('confidence')})"
                )
                print(f"    Reason: {g.get('reasoning')}")
            print()


def cmd_check(args, config, jira, gemini_model):
    """Check a specific issue."""
    issue = jira.get_issue(args.issue_key)
    result = analyze_issue(issue, config, gemini_model)

    if args.json:
        print(json.dumps(result, indent=2))
    else:
        print(f"Issue: {result['key']}")
        print(f"Summary: {issue.get('fields', {}).get('summary', '')}")
        print(f"Image detected: {result['image'] or 'Not detected'}")
        print(
            f"Current component(s): {', '.join(result['current_components']) or 'None'}"
        )
        print(f"Expected component: {result['expected_component'] or 'Unknown'}")
        print(f"Miscategorized: {'Yes' if result['is_miscategorized'] else 'No'}")

        if result["gemini_suggestion"]:
            g = result["gemini_suggestion"]
            print(f"\nGemini suggestion: {g.get('suggested_component')}")
            print(f"Confidence: {g.get('confidence')}")
            print(f"Reasoning: {g.get('reasoning')}")


def cmd_fix(args, config, jira, gemini_model):
    """Fix miscategorized issues."""
    jql = config.get("jira", {}).get(
        "jql_filter", 'summary ~ "cve-*" AND labels = security'
    )
    project = config.get("jira", {}).get("project", "SRVKP")
    full_jql = f"project = {project} AND {jql}"

    print("Fetching issues...", file=sys.stderr)
    issues = jira.fetch_all_issues(full_jql)

    fixed = 0
    for issue in issues:
        result = analyze_issue(issue, config, gemini_model)

        if not result["is_miscategorized"]:
            continue

        # Determine new component
        new_component = result["expected_component"]
        if not new_component and result["gemini_suggestion"]:
            g = result["gemini_suggestion"]
            if g.get("confidence") in ("high", "medium"):
                new_component = g.get("suggested_component")

        if not new_component:
            continue

        print(f"\n{result['key']}: {result['summary']}")
        print(f"  Current: {', '.join(result['current_components']) or 'None'}")
        print(f"  Suggested: {new_component}")

        if args.dry_run:
            print("  [DRY RUN] Would update component")
            fixed += 1
            continue

        if args.interactive:
            confirm = input("  Apply fix? [y/N]: ").strip().lower()
            if confirm != "y":
                print("  Skipped")
                continue

        try:
            jira.update_issue(result["key"], {"components": [{"name": new_component}]})
            print("  Updated!")
            fixed += 1
        except Exception as e:
            print(f"  Error: {e}")

    print(f"\n{'Would fix' if args.dry_run else 'Fixed'} {fixed} issues")


def cmd_report(args, config, jira, gemini_model):
    """Generate a markdown report of all CVE issues."""
    jql = config.get("jira", {}).get(
        "jql_filter", 'summary ~ "cve-*" AND labels = security'
    )
    project = config.get("jira", {}).get("project", "SRVKP")
    full_jql = f"project = {project} AND {jql}"

    print(f"Fetching issues with JQL: {full_jql}", file=sys.stderr)
    issues = jira.fetch_all_issues(full_jql)
    print(f"Found {len(issues)} issues", file=sys.stderr)

    # Analyze all issues
    results = []
    for i, issue in enumerate(issues):
        print(f"  Analyzing {i+1}/{len(issues)}...", file=sys.stderr, end="\r")
        result = analyze_issue(issue, config, gemini_model)
        # Add extra fields from the raw issue
        result["status"] = issue.get("fields", {}).get("status", {}).get("name", "Unknown")
        result["priority"] = issue.get("fields", {}).get("priority", {}).get("name", "Undefined")
        result["full_summary"] = issue.get("fields", {}).get("summary", "")
        results.append(result)
    print(file=sys.stderr)

    # Group by component (use expected or current)
    by_component = defaultdict(list)
    for r in results:
        component = r["expected_component"]
        if not component and r["gemini_suggestion"]:
            component = r["gemini_suggestion"].get("suggested_component")
        if not component:
            component = r["current_components"][0] if r["current_components"] else "Unknown"
        by_component[component].append(r)

    # Priority order for sorting
    priority_order = {"Critical": 0, "Blocker": 1, "High": 2, "Medium": 3, "Low": 4, "Undefined": 5}

    # Sort issues within each component by priority
    for component in by_component:
        by_component[component].sort(key=lambda x: priority_order.get(x["priority"], 99))

    # Count stats
    total = len(results)
    miscategorized = sum(1 for r in results if r["is_miscategorized"])
    priority_counts = defaultdict(int)
    for r in results:
        p = r["priority"]
        if p in ("Critical", "Blocker", "High"):
            priority_counts["High"] += 1
        elif p == "Medium":
            priority_counts["Medium"] += 1
        else:
            priority_counts["Low/Undefined"] += 1

    # Generate markdown
    today = datetime.now().strftime("%Y-%m-%d")
    lines = [
        f"# CVE Triage Report",
        f"",
        f"Generated: {today}",
        f"",
        f"## Summary",
        f"",
        f"- **Total issues**: {total}",
        f"- **High priority** (Critical/Blocker/High): {priority_counts['High']}",
        f"- **Medium priority**: {priority_counts['Medium']}",
        f"- **Low/Undefined**: {priority_counts['Low/Undefined']}",
        f"- **Miscategorized**: {miscategorized}",
        f"",
        f"## By Component",
        f"",
    ]

    for component in sorted(by_component.keys()):
        issues_list = by_component[component]
        lines.append(f"### {component} ({len(issues_list)} issues)")
        lines.append("")

        # Group by priority within component
        current_priority = None
        for r in issues_list:
            if r["priority"] != current_priority:
                current_priority = r["priority"]
                lines.append(f"#### {current_priority}")
                lines.append("")

            # Format issue line
            misc_note = ""
            if r["is_miscategorized"]:
                current = ", ".join(r["current_components"]) or "None"
                expected = r["expected_component"]
                if not expected and r["gemini_suggestion"]:
                    expected = r["gemini_suggestion"].get("suggested_component")
                misc_note = f" | **Currently: {current}, Should be: {expected}**"

            lines.append(f"- **{r['key']}**: {r['full_summary'][:100]}")
            lines.append(f"  - Status: {r['status']}{misc_note}")
            lines.append("")

    # Miscategorized issues table
    misc_issues = [r for r in results if r["is_miscategorized"]]
    if misc_issues:
        lines.append("## Miscategorized Issues")
        lines.append("")
        lines.append("| Issue | Current | Expected | Confidence |")
        lines.append("|-------|---------|----------|------------|")
        for r in misc_issues:
            current = ", ".join(r["current_components"]) or "None"
            expected = r["expected_component"]
            confidence = ""
            if r["gemini_suggestion"]:
                if not expected:
                    expected = r["gemini_suggestion"].get("suggested_component", "")
                confidence = r["gemini_suggestion"].get("confidence", "")
            lines.append(f"| {r['key']} | {current} | {expected} | {confidence} |")
        lines.append("")

    report_content = "\n".join(lines)

    # Determine output path
    if args.output:
        output_path = Path(args.output)
    else:
        reports_dir = Path(__file__).parent / "reports"
        reports_dir.mkdir(exist_ok=True)
        output_path = reports_dir / f"cve-triage-{today}.md"

    output_path.write_text(report_content)
    print(f"Report written to: {output_path}")


# Available SRVKP components for the picker
JIRA_COMPONENTS = [
    "UI",
    "Tekton CLI",
    "Tekton Pipelines",
    "Tekton Chains",
    "Tekton Triggers",
    "Tekton Results",
    "Tekton Hub",
    "Pipelines as Code",
    "Operator",
    "Manual Approval",
    "Pruner",
]


def get_cache_path():
    """Get the path to the cache file."""
    cache_dir = Path(__file__).parent / "cache"
    cache_dir.mkdir(exist_ok=True)
    return cache_dir / "issues.json"


def load_cache():
    """Load cached issues from JSON file."""
    cache_path = get_cache_path()
    if not cache_path.exists():
        return None
    with open(cache_path) as f:
        return json.load(f)


def save_cache(cache_data):
    """Save issues to JSON cache file."""
    cache_path = get_cache_path()
    with open(cache_path, "w") as f:
        json.dump(cache_data, f, indent=2, default=str)


def refresh_cache(config, jira, gemini_model):
    """Fetch all issues, analyze them, and save to cache."""
    jql = config.get("jira", {}).get(
        "jql_filter", 'summary ~ "cve-*" AND labels = security'
    )
    project = config.get("jira", {}).get("project", "SRVKP")
    full_jql = f"project = {project} AND {jql}"

    print(f"Fetching issues with JQL: {full_jql}", file=sys.stderr)
    issues = jira.fetch_all_issues(full_jql)
    print(f"Found {len(issues)} issues", file=sys.stderr)

    # Analyze all issues
    results = []
    for i, issue in enumerate(issues):
        print(f"  Analyzing {i+1}/{len(issues)}...", file=sys.stderr, end="\r")
        result = analyze_issue(issue, config, gemini_model)
        # Add extra fields
        result["status"] = issue.get("fields", {}).get("status", {}).get("name", "Unknown")
        result["priority"] = issue.get("fields", {}).get("priority", {}).get("name", "Undefined")
        result["full_summary"] = issue.get("fields", {}).get("summary", "")
        result["triaged"] = False
        result["triaged_at"] = None
        result["action"] = None
        results.append(result)
    print(file=sys.stderr)

    cache_data = {
        "fetched_at": datetime.now().isoformat(),
        "total": len(results),
        "issues": results,
    }
    save_cache(cache_data)
    print(f"Cache saved: {len(results)} issues")
    return cache_data


def get_issue_for_reanalysis(jira, issue_key):
    """Fetch fresh issue data for re-analysis."""
    return jira.get_issue(issue_key)


def cmd_triage(args, config, jira, gemini_model):
    """Interactive triage of CVE issues."""
    # Load or refresh cache
    cache = load_cache()

    if args.refresh or cache is None:
        print("Refreshing cache...")
        cache = refresh_cache(config, jira, gemini_model)
        if not args.start and not args.auto and cache is not None:
            print("Cache refreshed. Run without --refresh to start triaging.")
            return

    # Get server URL for opening issues
    jayrah_config = load_jayrah_config()
    server_url = jayrah_config.get("server", "")

    # Filter to miscategorized issues not yet triaged
    pending = [
        (i, issue) for i, issue in enumerate(cache["issues"])
        if issue.get("is_miscategorized") and not issue.get("triaged")
    ]

    if not pending:
        print("No pending issues to triage!")
        triaged_count = sum(1 for i in cache["issues"] if i.get("triaged"))
        print(f"  Total: {cache['total']}, Triaged: {triaged_count}")
        return

    # Auto-triage mode
    if args.auto:
        cmd_triage_auto(args, config, jira, gemini_model, cache, pending)
        return

    print(f"\nStarting interactive triage: {len(pending)} issues pending")
    print("Commands: [y] accept suggestion, [c] choose component, [s] skip, [o] open, [q] quit\n")

    for pos, (cache_idx, issue) in enumerate(pending):
        suggested = issue.get("expected_component")
        confidence = ""
        if not suggested and issue.get("gemini_suggestion"):
            suggested = issue["gemini_suggestion"].get("suggested_component")
            confidence = f" ({issue['gemini_suggestion'].get('confidence', '')})"

        print(f"[{pos+1}/{len(pending)}] {issue['key']}")
        print(f"  Summary: {issue.get('full_summary', issue.get('summary', ''))[:100]}")
        print(f"  Current: {', '.join(issue['current_components']) or 'None'}")
        print(f"  Suggested: {suggested or 'Unknown'}{confidence}")
        print()

        while True:
            try:
                action = input(f"  Action [y/c/s/o/q]: ").strip().lower()
            except (KeyboardInterrupt, EOFError):
                action = "q"

            if action == "q":
                save_cache(cache)
                print("\nProgress saved. Exiting.")
                return

            elif action == "o":
                import subprocess
                url = f"{server_url}/browse/{issue['key']}"
                subprocess.run(["xdg-open", url], check=False)
                continue

            elif action == "s":
                cache["issues"][cache_idx]["triaged"] = True
                cache["issues"][cache_idx]["triaged_at"] = datetime.now().isoformat()
                cache["issues"][cache_idx]["action"] = "skipped"
                save_cache(cache)
                print("  Skipped.\n")
                break

            elif action == "y":
                if not suggested:
                    print("  No suggestion available. Use [c] to choose a component.")
                    continue
                try:
                    old_component = ", ".join(issue["current_components"]) or "None"
                    jira.update_issue(issue["key"], {"components": [{"name": suggested}]})
                    if args.comment:
                        comment = f"Component changed from {old_component} to {suggested} by CVE triage tool."
                        jira.add_comment(issue["key"], comment)
                    cache["issues"][cache_idx]["triaged"] = True
                    cache["issues"][cache_idx]["triaged_at"] = datetime.now().isoformat()
                    cache["issues"][cache_idx]["action"] = f"changed to {suggested}"
                    save_cache(cache)
                    print(f"  Changed to: {suggested}\n")
                except Exception as e:
                    print(f"  Error: {e}")
                break

            elif action == "c":
                print("\n  Select component:")
                for i, comp in enumerate(JIRA_COMPONENTS, 1):
                    print(f"    {i:2}. {comp}")
                try:
                    choice = input("  > ").strip()
                    if not choice.isdigit() or int(choice) < 1 or int(choice) > len(JIRA_COMPONENTS):
                        print("  Invalid choice.")
                        continue
                    new_component = JIRA_COMPONENTS[int(choice) - 1]
                    old_component = ", ".join(issue["current_components"]) or "None"
                    jira.update_issue(issue["key"], {"components": [{"name": new_component}]})
                    if args.comment:
                        comment = f"Component changed from {old_component} to {new_component} by CVE triage tool."
                        jira.add_comment(issue["key"], comment)
                    cache["issues"][cache_idx]["triaged"] = True
                    cache["issues"][cache_idx]["triaged_at"] = datetime.now().isoformat()
                    cache["issues"][cache_idx]["action"] = f"changed to {new_component}"
                    save_cache(cache)
                    print(f"  Changed to: {new_component}\n")
                except (KeyboardInterrupt, EOFError):
                    print("  Cancelled.")
                    continue
                except Exception as e:
                    print(f"  Error: {e}")
                    continue
                break

            else:
                print("  Unknown action. Use y/c/s/o/q")

    save_cache(cache)
    print("\nAll pending issues triaged!")


def cmd_triage_auto(args, config, jira, gemini_model, cache, pending):
    """Auto-triage mode: apply high/medium confidence suggestions automatically."""
    dry_run = args.dry_run
    auto_fixed = 0
    skipped_low = 0
    errors = 0

    print(f"\nAuto-triage mode: {len(pending)} issues to process")
    if dry_run:
        print("[DRY RUN] No changes will be made\n")
    else:
        print()

    for pos, (cache_idx, issue) in enumerate(pending):
        key = issue["key"]
        suggested = issue.get("expected_component")
        confidence = None

        # Get confidence from Gemini suggestion
        if issue.get("gemini_suggestion"):
            if not suggested:
                suggested = issue["gemini_suggestion"].get("suggested_component")
            confidence = issue["gemini_suggestion"].get("confidence")

        # Pattern match has implicit high confidence
        if issue.get("expected_component") and not confidence:
            confidence = "high"

        print(f"[{pos+1}/{len(pending)}] {key}: {issue.get('summary', '')[:60]}...")
        print(f"  Current: {', '.join(issue['current_components']) or 'None'}")
        print(f"  Suggested: {suggested or 'Unknown'} (confidence: {confidence or 'unknown'})")

        # If low confidence, re-ask Gemini for better analysis
        if confidence == "low" and gemini_model:
            print("  Low confidence - re-analyzing with Gemini...")
            try:
                fresh_issue = get_issue_for_reanalysis(jira, key)
                new_result = ask_gemini(
                    gemini_model, fresh_issue, config.get("components", []),
                    issue["current_components"]
                )
                if new_result:
                    new_confidence = new_result.get("confidence")
                    new_suggested = new_result.get("suggested_component")
                    print(f"  Re-analysis: {new_suggested} (confidence: {new_confidence})")
                    if new_confidence in ("high", "medium"):
                        suggested = new_suggested
                        confidence = new_confidence
                        # Update cache with new analysis
                        cache["issues"][cache_idx]["gemini_suggestion"] = new_result
            except Exception as e:
                print(f"  Re-analysis error: {e}")

        # Apply if high/medium confidence
        if confidence in ("high", "medium") and suggested:
            if dry_run:
                print(f"  [DRY RUN] Would change to: {suggested}")
                auto_fixed += 1
            else:
                try:
                    old_component = ", ".join(issue["current_components"]) or "None"
                    jira.update_issue(key, {"components": [{"name": suggested}]})
                    if args.comment:
                        comment = f"Component changed from {old_component} to {suggested} by CVE triage tool (auto)."
                        jira.add_comment(key, comment)
                    cache["issues"][cache_idx]["triaged"] = True
                    cache["issues"][cache_idx]["triaged_at"] = datetime.now().isoformat()
                    cache["issues"][cache_idx]["action"] = f"auto-changed to {suggested}"
                    print(f"  Changed to: {suggested}")
                    auto_fixed += 1
                except Exception as e:
                    print(f"  Error: {e}")
                    errors += 1
        else:
            print(f"  Skipped (low/no confidence)")
            if not dry_run:
                cache["issues"][cache_idx]["triaged"] = False  # Keep for manual triage
            skipped_low += 1

        print()

    if not dry_run:
        save_cache(cache)

    print(f"\nAuto-triage complete:")
    print(f"  {'Would fix' if dry_run else 'Fixed'}: {auto_fixed}")
    print(f"  Skipped (low confidence): {skipped_low}")
    if errors:
        print(f"  Errors: {errors}")


def main():
    parser = argparse.ArgumentParser(description="CVE Triage Tool")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # list command
    list_parser = subparsers.add_parser("list", help="List miscategorized issues")
    list_parser.add_argument("--all", action="store_true", help="Show all issues")

    # check command
    check_parser = subparsers.add_parser("check", help="Check a specific issue")
    check_parser.add_argument("issue_key", help="Issue key (e.g., SRVKP-10057)")

    # fix command
    fix_parser = subparsers.add_parser("fix", help="Fix miscategorized issues")
    fix_parser.add_argument(
        "--dry-run", action="store_true", help="Show what would change"
    )
    fix_parser.add_argument(
        "--interactive", action="store_true", help="Confirm each fix"
    )

    # report command
    report_parser = subparsers.add_parser(
        "report", help="Generate markdown report of all CVE issues"
    )
    report_parser.add_argument(
        "-o", "--output", help="Output file (default: reports/cve-triage-YYYY-MM-DD.md)"
    )

    # triage command
    triage_parser = subparsers.add_parser(
        "triage", help="Interactive triage of CVE issues"
    )
    triage_parser.add_argument(
        "--refresh", action="store_true", help="Refresh the cache before triaging"
    )
    triage_parser.add_argument(
        "--start", action="store_true", help="Start triaging after refresh"
    )
    triage_parser.add_argument(
        "--auto", action="store_true",
        help="Auto-apply high/medium confidence suggestions"
    )
    triage_parser.add_argument(
        "--dry-run", action="store_true", help="Show what would change (no updates)"
    )
    triage_parser.add_argument(
        "--comment", action="store_true",
        help="Add a comment to issues when changing component"
    )

    args = parser.parse_args()

    # Load configs
    config = load_config()
    jayrah_config = load_jayrah_config()

    # Initialize clients
    jira = JiraClient(jayrah_config)
    gemini_model = setup_gemini(config)

    # Dispatch command
    if args.command == "list":
        cmd_list(args, config, jira, gemini_model)
    elif args.command == "check":
        cmd_check(args, config, jira, gemini_model)
    elif args.command == "fix":
        cmd_fix(args, config, jira, gemini_model)
    elif args.command == "report":
        cmd_report(args, config, jira, gemini_model)
    elif args.command == "triage":
        cmd_triage(args, config, jira, gemini_model)


if __name__ == "__main__":
    main()
